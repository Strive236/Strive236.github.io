[{"content":"实验主题 Data Lab: Manipulating Bits\n关于怎么表示、存储、计算信息\n运行环境 只需要linux环境就行, 我用的是WSL2 + Ubuntu 22.04.4 LTS\n学习和实验材料 [1] 九曲阑干的视频(有点类似3blue1brown的风格)\n[2] 官方文档(其余材料均可在官网获得)\n实验过程 本实验是由一个个小的puzzle组成, 这些puzzle是关于操纵位的, 即计算机中信息的表示、存储和计算, 在完成这些puzzle时所能做的操作受限, 我的解决方案和puzzle的要求见bit.c文件\n下面一个个介绍实验:\nbitXor\n题目描述\n1 2 3 4 5 6 7 /* * bitXor - x^y using only ~ and \u0026amp; * Example: bitXor(4, 5) = 1 * Legal ops: ~ \u0026amp; * Max ops: 14 * Rating: 1 */ 思路\n只能用\u0026amp;和~来模拟实现^\n此处由布尔代数，其实本来直接 (~a \u0026amp; b) | (a \u0026amp; ~b) 即可, 但是此处不许用|, 所以再利用 a | b = ~(~a \u0026amp; ~b) , 可得最终公式为: ~(~(x \u0026amp; (~y)) \u0026amp; ~(y \u0026amp; (~x)))\n其实有点复杂了, 可供参考的一种更好的解决方式是 tmin\n题目描述\n1 2 3 4 5 6 /* * tmin - return minimum two\u0026#39;s complement integer * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 4 * Rating: 1 */ 思路\n找到最小的补码值, 即10\u0026hellip;0, 用移位操作可得 1 \u0026lt;\u0026lt; 31\nisTmax\n题目描述\n1 2 3 4 5 6 7 /* * isTmax - returns 1 if x is the maximum, two\u0026#39;s complement number, * and 0 otherwise * Legal ops: ! ~ \u0026amp; ^ | + * Max ops: 10 * Rating: 1 */ 思路\n即判断是不是01\u0026hellip;1\n我的解决方案是:\nx + 1为10\u0026hellip;0, x为01\u0026hellip;1，相与后取反为00\u0026hellip;0，再!其值为1\n即flag = !(~((x + 1) ^ x))\n但是由于11\u0026hellip;1也满足此条件, 所以再利用01\u0026hellip;1+1后不为0, 而11\u0026hellip;1+1后为0, 排除掉此情况\n即not_minus1 = !!(x + 1)\n最后二者相与可得\n即flag \u0026amp; not_minus1\naddOddBits\n题目描述\n1 2 3 4 5 6 7 8 /* * allOddBits - return 1 if all odd-numbered bits in word set to 1 * where bits are numbered from 0 (least significant) to 31 (most significant) * Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 12 * Rating: 2 */ 思路\n我的解决方案:\n将x中每个字节全部提取出来与0b10101010(0xaa)相与, 可得奇数位上情况, 最后再加上0b01010101(0x55), 再+1, 若第8位为1, 即成功\n1 2 3 x = (x \u0026gt;\u0026gt; 24) \u0026amp; (x \u0026gt;\u0026gt; 16) \u0026amp; (x \u0026gt;\u0026gt; 8) \u0026amp; x \u0026amp; 0xaa; x = (x | 0x55) + 1; return (x \u0026gt;\u0026gt; 8); negate\n题目描述\n1 2 3 4 5 6 7 /* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 5 * Rating: 2 */ 思路\n即求补码，直接 ~x + 1 即可\nisAsciiDigit\n题目描述\n1 2 3 4 5 6 7 8 9 /* * isAsciiDigit - return 1 if 0x30 \u0026lt;= x \u0026lt;= 0x39 (ASCII codes for characters \u0026#39;0\u0026#39; to \u0026#39;9\u0026#39;) * Example: isAsciiDigit(0x35) = 1. * isAsciiDigit(0x3a) = 0. * isAsciiDigit(0x05) = 0. * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 15 * Rating: 3 */ 思路\n0x30 - 0x39即\n0b00110000 - 0b00111001\n首先确保为正数，然后检查第4、5位是否为1，最后再用0x39来+上x的补码(即0x39 - x)，如果符号位不变位就搞定\n1 return (~(x \u0026gt;\u0026gt; 31)) \u0026amp; (x \u0026gt;\u0026gt; 4) \u0026amp; (x \u0026gt;\u0026gt; 5) \u0026amp; 1 \u0026amp; (~((0x39 + (~x) + 1) \u0026gt;\u0026gt; 31)); conditional\n题目描述\n1 2 3 4 5 6 7 /* * conditional - same as x ? y : z * Example: conditional(2,4,5) = 4 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 16 * Rating: 3 */ 思路\n1左移31为10\u0026hellip;0，然后右移31为11\u0026hellip;1\n0左移31为00\u0026hellip;0，然后右移31为00\u0026hellip;0 使用一个特殊的flag\n1 2 3 4 // flag为全1表示x大于0，为全0表示x\u0026lt;=0 // 用其来\u0026amp;y或z便能达到控制值的效果 int flag = ((!!x) \u0026lt;\u0026lt; 31) \u0026gt;\u0026gt; 31; return (flag \u0026amp; y) | ((~flag) \u0026amp; z); 此处提一嘴: a == b 等效于 !(a^b) , 是一个有用的小trick\nisLessOrEqual\n题目描述\n1 2 3 4 5 6 7 /* * isLessOrEqual - if x \u0026lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 24 * Rating: 3 */ 思路\n逻辑有点复杂，最重要的是要把 x \u0026lt;= y 的判断变成 x - y \u0026lt;= 0 , 然后根据 x - y 的结果进行讨论\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 将x \u0026lt;= y转换成x - y \u0026lt;= 0, 去观察x - y // x - y有以下几种情况 // x, y同号，不会溢出，直接取决于最终结果是否\u0026lt;=0 // x为负数，y为正数，x - y 如果不溢出则还是负数，如果溢出符号位会变，会变成正数 // x为正数，y为负数，x - y 如果不溢出则还是正数，如果溢出符号位会变，会变成负数 // x \u0026lt;= y有两种情况：1. xy同号且x-y\u0026lt;=0 2. x为负y为正 int x_minux_y = x + (~y) + 1; int x_minux_y_lessOrEqual = (x_minux_y \u0026gt;\u0026gt; 31) | (!x_minux_y \u0026amp; 1); // xy同号 int same_sign = (~((x ^ y) \u0026gt;\u0026gt; 31)) \u0026amp; 1; int x_negative_y_positive = (x \u0026gt;\u0026gt; 31) \u0026amp; (~(y \u0026gt;\u0026gt; 31)) \u0026amp; 1; int res = (same_sign \u0026amp; x_minux_y_lessOrEqual) | x_negative_y_positive; return res; logicalNeg\n题目描述\n1 2 3 4 5 6 7 8 /* * logicalNeg - implement the ! operator, using all of * the legal operators except ! * Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 * Legal ops: ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 12 * Rating: 4 */ 思路\n注意, !x 实际上等效于 x == 0\n故我们只需要判断其为0即可\n1 2 3 4 5 6 // 破局点：0-1即(0 + (~1 + 1)) 二进制表示为11...1, 符号位会变号 int sign_x = (~(x \u0026gt;\u0026gt; 31) \u0026amp; 1); // 符号位为0 int x_minus_1 = x + (~1 + 1); // 0-1后的值 int sign_x_minus_1 = (x_minus_1 \u0026gt;\u0026gt; 31) \u0026amp; 1; // -1后符号位为1 int zero = sign_x \u0026amp; sign_x_minus_1; return zero; 一种可参考的简便写法:\n1 2 3 4 // ~x+1\u0026gt;\u0026gt;31 , 在x为正数时为1, x为0和负数时为0, 由此可区分正数、负数和0 // 再去区分负数和0, 将上式与x做与运算 // 即 x | (~x+1\u0026gt;\u0026gt;31) , 其值如果为-1 则表示x!=0, 其值为0则表示x==0 return ((x | (~x +1)) \u0026gt;\u0026gt; 31) + 1; howManyBits\n题目描述\n1 2 3 4 5 6 7 8 9 10 11 12 /* howManyBits - return the minimum number of bits required to represent x in * two\u0026#39;s complement * Examples: howManyBits(12) = 5 * howManyBits(298) = 10 * howManyBits(-5) = 4 * howManyBits(0) = 1 * howManyBits(-1) = 1 * howManyBits(0x80000000) = 32 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 90 * Rating: 4 */ 思路\n太难了没想出来, 最后gpt代劳的二分法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 二分法：5位2进制数可表示0 - 31，最后再+1即可(每次选一半来检查，选有1的那边) int sign, bit16, bit8, bit4, bit2, bit1, bit0; // 获取符号位 sign = x \u0026gt;\u0026gt; 31; // 如果是负数，将其取反 x = (sign \u0026amp; ~x) | (~sign \u0026amp; x); // 二分查找最高位的1 bit16 = !!(x \u0026gt;\u0026gt; 16) \u0026lt;\u0026lt; 4; // 检查16位是否有1 若有1则bit16为10000，反之为0 x = x \u0026gt;\u0026gt; bit16; // 如果有，右移16位 bit8 = !!(x \u0026gt;\u0026gt; 8) \u0026lt;\u0026lt; 3; // 检查8位是否有1 x = x \u0026gt;\u0026gt; bit8; bit4 = !!(x \u0026gt;\u0026gt; 4) \u0026lt;\u0026lt; 2; // 检查4位是否有1 x = x \u0026gt;\u0026gt; bit4; bit2 = !!(x \u0026gt;\u0026gt; 2) \u0026lt;\u0026lt; 1; // 检查2位是否有1 x = x \u0026gt;\u0026gt; bit2; bit1 = !!(x \u0026gt;\u0026gt; 1); // 检查次高位是否为1 x = x \u0026gt;\u0026gt; bit1; bit0 = x; // 检查最后一位 // 计算总位数并加上符号位 return bit16 + bit8 + bit4 + bit2 + bit1 + bit0 + 1; 没想到还能这样二分\nfloatScale2\n题目描述\n1 2 3 4 5 6 7 8 9 10 11 /* * floatScale2 - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int\u0026#39;s, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, \u0026amp;\u0026amp;. also if, while * Max ops: 30 * Rating: 4 */ 思路\n浮点数x2, 按照ieee 754的浮点数标准实现即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 unsigned sign = uf \u0026gt;\u0026gt; 31 \u0026amp; 1; unsigned exp = uf \u0026gt;\u0026gt; 23 \u0026amp; 0xff; unsigned frac = uf \u0026amp; 0x7fffff; // 如果exp全为1, 即数为NaN或无穷大, 即x2无意义，直接返回参数 if (exp == 0xff) return uf; // 如果exp全为0，则直接frac左移一位即可 if (!exp) { frac = frac \u0026lt;\u0026lt; 1; } else { // 如果exp不全为0，则+1 exp = exp + 1; // 如果exp+1后全为1且frac不为0, 即数为NaN, 直接返回参数 if ((exp == 0xff) \u0026amp;\u0026amp; (frac != 0)) return uf; } return (sign \u0026lt;\u0026lt; 31) + (exp \u0026lt;\u0026lt; 23) + frac; floatFloat2Int\n题目描述\n1 2 3 4 5 6 7 8 9 10 11 12 /* * floatFloat2Int - Return bit-level equivalent of expression (int) f * for floating point argument f. * Argument is passed as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point value. * Anything out of range (including NaN and infinity) should return * 0x80000000u. * Legal ops: Any integer/unsigned operations incl. ||, \u0026amp;\u0026amp;. also if, while * Max ops: 30 * Rating: 4 */ 思路\n将浮点数转换成int, 实际上即利用浮点数的值的公式进行转换即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 提取各部分 unsigned sign = uf \u0026gt;\u0026gt; 31 \u0026amp; 1; unsigned exp = uf \u0026gt;\u0026gt; 23 \u0026amp; 0xff; unsigned frac = uf \u0026amp; 0x7fffff; int e = -23; // 如果exp全为1, 即数为NaN或无穷大, 返回0x80000000u if (exp == 0xff) return 0x80000000u; // 如果exp全为0，小数部分为0.frac, 判断是否为-0 else if (exp == 0x0) { // 如果为-0 if ((sign == 1) \u0026amp;\u0026amp; (!frac)) return 0; else { e = e + exp - 127; } } // 其他情况, exp为1-254之间值，小数部分为1.frac else { e = e + exp - 127; frac = frac | 0x800000; // 将0.frac改成1.frac } // 判断e正负号决定左移右移, 注意e绝对值大于等于32时会有意想不到的效果 if (e \u0026lt;= -32) return 0; else if (e \u0026gt;= 32) return 0x80000000u; else if (e \u0026gt;= 0) frac = frac \u0026lt;\u0026lt; e; else frac = frac \u0026gt;\u0026gt; (-e); // -0特殊处理 if ((frac == 0) \u0026amp;\u0026amp; (sign == 1)) return 0; // 此时处理出来结果是unsigned，还需要转成int if (sign == 1) return -(frac \u0026amp; 0xffffffff); // 负数取补码 else return frac; // 正数直接取 gpt的简单做法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int floatFloat2Int(unsigned uf) { int sign = uf \u0026gt;\u0026gt; 31; int exp = ((uf \u0026gt;\u0026gt; 23) \u0026amp; 0xFF) - 127; int frac = (uf \u0026amp; 0x7FFFFF) | 0x800000; // 添加隐含的前导1 // 特殊情况处理 if (exp \u0026gt; 31) return 0x80000000u; // 超出范围或无穷大 if (exp \u0026lt; 0) return 0; // 小于1的数 // 正常情况处理 if (exp \u0026gt; 23) frac \u0026lt;\u0026lt;= (exp - 23); else frac \u0026gt;\u0026gt;= (23 - exp); // 应用符号 if (sign) return -frac; return frac; floatPower2\n题目描述\n1 2 3 4 5 6 7 8 9 10 11 12 13 /* * floatPower2 - Return bit-level equivalent of the expression 2.0^x * (2.0 raised to the power x) for any 32-bit integer x. * * The unsigned value that is returned should have the identical bit * representation as the single-precision floating-point number 2.0^x. * If the result is too small to be represented as a denorm, return * 0. If too large, return +INF. * * Legal ops: Any integer/unsigned operations incl. ||, \u0026amp;\u0026amp;. Also if, while * Max ops: 30 * Rating: 4 */ 思路\n1 2 3 4 5 6 7 8 // 用浮点数来表示2^x次方，实际上就是操作浮点数的指数部分 if (x + 127 \u0026lt;= 0) return 0; if (x + 127 \u0026gt; 254) return 0x7f800000; // 返回+INF // sign必为0 // frac为0，exp为x + 127 return (x + 127) \u0026lt;\u0026lt; 23; 结果 出现以下结果即正确\n收获 学到了很多位运算的技巧, 也进一步深化了ieee754的浮点数实现, 原来这才是真正的理解, csapp神课名不虚传! 希望八月份能把它给完结了, 好好补补基础\n参考的答案链接 [1] 知乎——周小伦\n","permalink":"https://Strive236.github.io/posts/tech/csapp-lab1/","summary":"实验主题 Data Lab: Manipulating Bits 关于怎么表示、存储、计算信息 运行环境 只需要linux环境就行, 我用的是WSL2 + Ubuntu 22.04.4 LTS 学习和实验材料 [1] 九曲阑干的视频(有点类","title":"CSAPP 开始 \u0026\u0026 Lab1 过程与收获"},{"content":"感慨 花了一个晚上终于使用github pages + hugo成功搭建好了blog\n参考文献 [1] cuttontail\u0026rsquo;s blog\n[2] PaperMod主题官方文档\n[3] sulv\u0026rsquo;s blog\n[4] shaohanyun\u0026rsquo;s blog\n","permalink":"https://Strive236.github.io/posts/tech/start/","summary":"感慨 花了一个晚上终于使用github pages + hugo成功搭建好了blog 参考文献 [1] cuttontail\u0026rsquo;s blog [2] PaperMod主题官方文档 [3] sulv\u0026rsquo;s blog [4] shaohanyun\u0026rsquo;s blog","title":"博客初始化"},{"content":"Hi there👋, I\u0026rsquo;m a Strive236.\nI\u0026rsquo;m a software engineering student from Xi\u0026rsquo;an JiaoTong University.\nI\u0026rsquo;m passionate about all things interesting.\nRecently, I have been learning algorithms and preparing for further study.\nFeel free to contact me by email.\n","permalink":"https://Strive236.github.io/about/","summary":"Hi there👋, I\u0026rsquo;m a Strive236. I\u0026rsquo;m a software engineering student from Xi\u0026rsquo;an JiaoTong University. I\u0026rsquo;m passionate about all things interesting. Recently, I have been learning algorithms and preparing for further study. Feel free to contact me by email.","title":"About Me"}]